#summary Tilepyramider configuration and deployment to Google Maps

<wiki:toc max_depth="2" />

= Introduction =

Google Maps is the granddaddy of tile-based web mapping interfaces, and is arguably still the best.  It also has very reasonable [http://code.google.com/apis/maps/terms.html licensing terms].

Their API also allows overlaying of custom tiles on top of their excellent base data.  The [tilepyramider] tool can construct a set of tiles that can be used for this purpose.

= Building the tile pyramid =

We first build our tile pyramid, which is a directory structure of tile images based on zoom level and x and y coordinates. The tilepyramider command requires an argument that is the path to a cumberland map xml file. This is a simple xml format which stores data source info (shapefile, database) and symbology (colors, line widths, etc.).

We call the tool as so:

{{{
tilepyramider.exe -x=7 -c=googlemaps -o=/home/scottell/Desktop/gm ../../../Cumberland.Tests/maps/mexico.xml
}}}

The 'c' option specifies that we output to consume in Google Maps.  The 'x' option is the max zoom level (the default minimum is 0) which prevents tiles from being created above that level.  The 'o' option specifies the output directory for  our tile pyramid.

_Note: Google Maps is the default consumer, so the c option can be omitted in this case._

= Deployment = 

In order to use Google Maps on your website, you will need a key ([http://code.google.com/apis/maps/signup.html sign up here]).  Finally, you will need to add the html and script to your web page:

Add a div element for the map:

{{{
<div id="map_canvas" style="width: 500px; height: 300px"></div>
}}}

And in the head, a reference to google maps script (replace with your key):

{{{
<script src="http://maps.google.com/maps?file=api&amp;v=2&amp;key={your key}"   type="text/javascript"></script>
}}}

Next, the script to load the map and tile overlay:

{{{
<script type="text/javascript">

function initialize() 
{
	if (GBrowserIsCompatible()) 
	{
		var map;
	        map = new GMap2(document.getElementById("map_canvas"));
	        map.setCenter(new GLatLng(24.5, -81.7), 9);
	        map.addControl(new GSmallMapControl());
	        map.addControl(new GMapTypeControl());
	        
		var tileLayerOverlay = new GTileLayerOverlay(
			new GTileLayer(null, null, null, {
			    tileUrlTemplate: '/tiles/reefs/{Z}/{X}/{Y}.png', 
			    isPng:true,
			    opacity:1.0
			  })
			);
			
		map.addOverlay(tileLayerOverlay);
	}
}
</script>

}}}

You'll need to point map.setCenter to the center longitude/latitude of where you want your map (and at what zoom level).  Also, the GTileLayerOverlay.tileUrlTemplate property should be set to the path where you uploaded your tiles generated by tilepyramider.  This property is used by Google Maps to acquire tiles (it replaces the {Z},{X},{Y} with the tile coordinates as requested).

Finally, handle loading/unloading in the html body element:

{{{
<body onload="initialize();" onunload="GUnload();">
}}}

= Clipping to tile boundaries =

If your tiles are not worldwide, then you will want to filter out any tile requests.  To do this you'll need to set the GTileLayer.getTileUrl property instead of the tileUrlTemplate:

{{{
var tl = new GTileLayer(null, null, null, {
    isPng:true,
    opacity:1.0
    });
tl.getTileUrl = CustomGetTileUrl;

var tileLayerOverlay = new GTileLayerOverlay(tl);
map.addOverlay(tileLayerOverlay);
}}}

This method will be responsible for filtering tile requests:

{{{
function CustomGetTileUrl(point,zoom)
{
	if (zoom > 16)
	{
		return 'blanktile.png';
	}

	// Define our tile boundaries
	// Note: origin in google maps is top-left
	var minLL = new GLatLng(24.67,-81.99);
	var maxLL = new GLatLng(24.29,-81.48);

	// convert our lat/long values to world pixel coordinates
	var currentProjection = G_NORMAL_MAP.getProjection();
	var minPixelPt = currentProjection.fromLatLngToPixel(minLL, zoom);
	var maxPixelPt = currentProjection.fromLatLngToPixel(maxLL, zoom);

	// convert our world pixel coordinates to tile coordinates 

	var minTileCoord = new GPoint();
	minTileCoord.x = Math.floor(minPixelPt.x / 256);
	minTileCoord.y = Math.floor(minPixelPt.y / 256);

	var maxTileCoord = new GPoint();
	maxTileCoord.x = Math.floor(maxPixelPt.x / 256);
	maxTileCoord.y = Math.floor(maxPixelPt.y / 256);

	// filter out any tile requests outside of our bounds
	if (point.x < minTileCoord.x || 
			point.x > maxTileCoord.x ||
			point.y < minTileCoord.y ||
			point.y > maxTileCoord.y)
	{
		return 'blanktile.png';
	}


	return 'reefs/' + zoom + '/' + point.x + '_' + point.y + '.png';
}
}}}

Basically, it shows a blank image tile whenever the map is out of scale or the tile requested is not within our bounds.  You'll need to edit this to fit your scale/bounds requirements.